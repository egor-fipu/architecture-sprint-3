# Задание 1. Анализ и планирование

### [Диаграмма контекста Монолитного приложения](context/Monolith-Context.puml)

## Проблемы существующего монолитного решения и их влияние на бизнес-задачи компании "Тёплый дом"
1. Сложности с масштабируемостью и производительностью:
- Монолитная архитектура ограничивает возможности масштабирования системы. В текущем состоянии приложение не позволяет масштабировать отдельные модули, такие как управление устройствами или мониторинг. Для поддержки большого количества новых пользователей и устройств система должна быть гибкой и масштабируемой.
- При увеличении числа подключенных домов или посёлков возрастёт нагрузка на сервер, что может привести к задержкам и ухудшению производительности.

2. Ограниченная гибкость для добавления новых функций:
- Монолитная структура затрудняет добавление новых модулей, таких как управление освещением, воротами и камерами наблюдения. Каждое изменение требует редактирования и тестирования всего приложения.
- Чтобы соответствовать новым бизнес-целям, компании нужно будет внедрять изменения более динамично и независимо, однако в монолите любое добавление или изменение требует полного пересмотра и деплоя всей системы.

3. Невозможность независимого развертывания и обновления:
- В монолитной архитектуре обновление или исправление ошибок требует остановки всего приложения. Это снижает доступность системы, что особенно критично для управления домом, где важна стабильность и непрерывность работы.
- Например, если нужно внести изменения в работу только одного модуля, потребуется провести развертывание всего приложения, что может повлиять на других пользователей и устройства.

4. Отсутствие отказоустойчивости:
- Если один из компонентов приложения выходит из строя, это может повлиять на всю систему. В монолитном приложении сбой в одном модуле (например, при высокой нагрузке) может повлиять на доступность других сервисов.
- В условиях целевой экосистемы, где требуется управление несколькими устройствами и датчиками, монолитное приложение не сможет эффективно справляться с отказами отдельных модулей без угрозы для остальных частей системы.

5. Синхронное взаимодействие и высокая зависимость от сервера:
- В текущем решении все запросы обрабатываются синхронно, что приводит к задержкам при большом числе обращений к серверу. Для IoT-устройств, которые требуют быстрого отклика, это становится серьезным ограничением.
- Асинхронное взаимодействие с датчиками и устройствами повысило бы производительность и стабильность системы, но текущая архитектура монолита не поддерживает такого подхода.

6. Зависимость от специалистов для установки и подключения:
- В настоящее время установка системы требует выезда специалиста, что увеличивает затраты и снижает удобство для клиентов. Монолитное приложение не поддерживает самообслуживание и автоматическую настройку устройств, что становится критическим с ростом числа пользователей.
- Целевая экосистема предполагает, что клиенты смогут сами подключать устройства через стандартные протоколы. Текущая архитектура не приспособлена к такому самообслуживанию.

### Заключение
Переход к микросервисной архитектуре будет способствовать решению всех этих проблем. Микросервисы позволят компании развивать каждый модуль экосистемы независимо, обеспечат отказоустойчивость, гибкость масштабирования, а также возможность легко добавлять новые функции, соответствующие бизнес-целям компании.

## Анализ доменов и контекстов
Примерные домены:
- Управление отоплением
- Управление освещением
- Управление умными воротами
- Наблюдение за домом (камеры, сенсоры)
- Управление пользователями и их устройствами
- Администрирование и поддержка системы

# Задание 2. Проектирование микросервисной архитектуры

## Каждый домен можно преобразовать в микросервис
- Микросервис для управления отоплением
- Микросервис для управления освещением
- Микросервис для управления устройствами (регистрация и настройка)
- Микросервис для наблюдения (видеонаблюдение и сенсоры)
- Микросервис для управления воротами
- Микросервис для управления пользователями и авторизацией

## Взаимодействие между микросервисами:
Микросервисы могут взаимодействовать через API Gateway и шину данных Kafka. 
Это обеспечит масштабируемость, асинхронность и упрощение коммуникации между сервисами.

### [C4 — Уровень контейнеров](container/Containers.puml)

### [C4 — Уровень компонентов](container/Components.puml)

### C4 — Уровень кода
- [Управление отоплением](code/Heating-Service-Code.puml)
- [Управление пользователями](code/User-Service-Code.puml)


# Задание 3. Разработка ER-диаграммы

### [ER-диаграмма](ERD.puml)

## Идентификация сущностей и их атрибутов
1. User (Пользователь)
- id — уникальный идентификатор пользователя.
- name — имя пользователя.
- email — email пользователя.
- password_hash — хеш пароля.
- created_at — дата создания пользователя.

2. House (Дом)
- id — уникальный идентификатор дома.
- address — адрес дома.
- user_id — идентификатор пользователя (внешний ключ к User).

3. Device (Устройство)
- id — уникальный идентификатор устройства.
- type_id — идентификатор типа устройства (внешний ключ к DeviceType).
- house_id — идентификатор дома (внешний ключ к House).
- serial_number — серийный номер устройства.
- status — текущее состояние устройства (включено/выключено).
- installed_at — дата установки устройства.

4. DeviceType (Тип устройства)
- id — уникальный идентификатор типа устройства.
- name — название типа устройства (например, «отопление», «освещение»).
- description — описание типа устройства.

5. Module (Модуль)
- id — уникальный идентификатор модуля.
- name — название модуля.
- description — описание модуля.
- created_at — дата создания модуля.

6. TelemetryData (Телеметрия)
- id — уникальный идентификатор записи телеметрии.
- device_id — идентификатор устройства (внешний ключ к Device).
- timestamp — время записи телеметрии.
- temperature — температура (если устройство связано с отоплением).
- power_status — статус включения (для устройств с функцией питания).
- other_data — другие параметры телеметрии (в формате JSON для гибкости).

## Описание связей между сущностями
- User — House: Один пользователь может иметь несколько домов (один-ко-многим).
- House — Device: Один дом может содержать несколько устройств, и каждое устройство привязано к одному дому (один-ко-многим).
- Device — DeviceType: Каждое устройство имеет один тип, но один тип устройства может быть у многих устройств (один-ко-многим).
- Device — TelemetryData: Одно устройство может иметь множество записей телеметрии (один-ко-многим).
- DeviceType — Module: Один тип устройства может быть частью нескольких модулей, а один модуль может включать несколько типов устройств (многие-ко-многим). Для этого понадобится связующая таблица Module_DeviceType.